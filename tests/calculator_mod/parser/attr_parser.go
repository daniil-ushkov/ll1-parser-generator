// Code generated by daniil-ushkov LL(1) parser generator; DO NOT EDIT.
package parser

import (
	"fmt"
	"strconv"
)

func __fmt_unused_import_ignore() {
	fmt.Print()
}

func __strconv_unused_import_ignore() {
	_, _ = strconv.Atoi("12345")
}

func log(val1, val2 int) int {
	res := 0
	for val1 != 1 {
		val1 /= val2
		res++
	}
	return res
}

type AttrParser struct {
	Lexer Lexer
}

type Attr map[string]interface{}

func (__p *AttrParser) Parse() (Attr, error) {
	return __p.ParseS(Attr{})
}

func (__p *AttrParser) ParseE(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case LP, NUM, SUB:
		t, __err := __p.ParseT(Attr{})
		_ = t
		if __err != nil {
			return nil, __err
		}

		e1, __err := __p.ParseE1(Attr{"acc": t["val"]})
		_ = e1
		if __err != nil {
			return nil, __err
		}

		res["val"] = e1["val"]

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}

func (__p *AttrParser) ParseE1(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case PLUS:
		if __p.Lexer.Get().Symbol != PLUS {
			return nil, fmt.Errorf("PLUS expected")
		}
		__unnamed0 := __p.Lexer.Get().Lexeme
		_ = __unnamed0
		__p.Lexer.MoveNext()

		t, __err := __p.ParseT(Attr{})
		_ = t
		if __err != nil {
			return nil, __err
		}

		e1, __err := __p.ParseE1(Attr{"acc": t["val"].(int) + attr["acc"].(int)})
		_ = e1
		if __err != nil {
			return nil, __err
		}

		res["val"] = e1["val"]
	case SUB:
		if __p.Lexer.Get().Symbol != SUB {
			return nil, fmt.Errorf("SUB expected")
		}
		__unnamed1 := __p.Lexer.Get().Lexeme
		_ = __unnamed1
		__p.Lexer.MoveNext()

		t, __err := __p.ParseT(Attr{})
		_ = t
		if __err != nil {
			return nil, __err
		}

		e1, __err := __p.ParseE1(Attr{"acc": attr["acc"].(int) - t["val"].(int)})
		_ = e1
		if __err != nil {
			return nil, __err
		}

		res["val"] = e1["val"]
	case EOF, RP:
		res["val"] = attr["acc"]

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}

func (__p *AttrParser) ParseT(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case LP, NUM, SUB:
		f, __err := __p.ParseF(Attr{})
		_ = f
		if __err != nil {
			return nil, __err
		}

		t1, __err := __p.ParseT1(Attr{"acc": f["val"]})
		_ = t1
		if __err != nil {
			return nil, __err
		}

		res["val"] = t1["val"]

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}

func (__p *AttrParser) ParseT1(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case MUL:
		if __p.Lexer.Get().Symbol != MUL {
			return nil, fmt.Errorf("MUL expected")
		}
		__unnamed2 := __p.Lexer.Get().Lexeme
		_ = __unnamed2
		__p.Lexer.MoveNext()

		f, __err := __p.ParseF(Attr{})
		_ = f
		if __err != nil {
			return nil, __err
		}

		t1, __err := __p.ParseT1(Attr{"acc": f["val"].(int) * attr["acc"].(int)})
		_ = t1
		if __err != nil {
			return nil, __err
		}

		res["val"] = t1["val"]
	case DIV:
		if __p.Lexer.Get().Symbol != DIV {
			return nil, fmt.Errorf("DIV expected")
		}
		__unnamed3 := __p.Lexer.Get().Lexeme
		_ = __unnamed3
		__p.Lexer.MoveNext()

		f, __err := __p.ParseF(Attr{})
		_ = f
		if __err != nil {
			return nil, __err
		}

		t1, __err := __p.ParseT1(Attr{"acc": attr["acc"].(int) / f["val"].(int)})
		_ = t1
		if __err != nil {
			return nil, __err
		}

		res["val"] = t1["val"]
	case SUB, EOF, RP, PLUS:
		res["val"] = attr["acc"]

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}

func (__p *AttrParser) ParseF(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case LP, NUM, SUB:
		l, __err := __p.ParseL(Attr{})
		_ = l
		if __err != nil {
			return nil, __err
		}

		l1, __err := __p.ParseL1(Attr{"acc": l["val"]})
		_ = l1
		if __err != nil {
			return nil, __err
		}

		res["val"] = l1["val"]

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}

func (__p *AttrParser) ParseL1(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case LOG:
		if __p.Lexer.Get().Symbol != LOG {
			return nil, fmt.Errorf("LOG expected")
		}
		__unnamed4 := __p.Lexer.Get().Lexeme
		_ = __unnamed4
		__p.Lexer.MoveNext()

		f, __err := __p.ParseF(Attr{})
		_ = f
		if __err != nil {
			return nil, __err
		}

		res["val"] = log(attr["acc"].(int), f["val"].(int))
	case PLUS, SUB, RP, MUL, DIV, EOF:
		res["val"] = attr["acc"]

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}

func (__p *AttrParser) ParseL(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case LP:
		if __p.Lexer.Get().Symbol != LP {
			return nil, fmt.Errorf("LP expected")
		}
		__unnamed5 := __p.Lexer.Get().Lexeme
		_ = __unnamed5
		__p.Lexer.MoveNext()

		e, __err := __p.ParseE(Attr{})
		_ = e
		if __err != nil {
			return nil, __err
		}

		if __p.Lexer.Get().Symbol != RP {
			return nil, fmt.Errorf("RP expected")
		}
		__unnamed6 := __p.Lexer.Get().Lexeme
		_ = __unnamed6
		__p.Lexer.MoveNext()

		res["val"] = e["val"]
	case NUM:
		if __p.Lexer.Get().Symbol != NUM {
			return nil, fmt.Errorf("NUM expected")
		}
		n := __p.Lexer.Get().Lexeme
		_ = n
		__p.Lexer.MoveNext()

		res["val"], _ = strconv.Atoi(n)
	case SUB:
		if __p.Lexer.Get().Symbol != SUB {
			return nil, fmt.Errorf("SUB expected")
		}
		__unnamed7 := __p.Lexer.Get().Lexeme
		_ = __unnamed7
		__p.Lexer.MoveNext()

		if __p.Lexer.Get().Symbol != NUM {
			return nil, fmt.Errorf("NUM expected")
		}
		n := __p.Lexer.Get().Lexeme
		_ = n
		__p.Lexer.MoveNext()

		x, _ := strconv.Atoi(n)
		res["val"] = -x

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}

func (__p *AttrParser) ParseS(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
	case NUM, SUB, LP:
		e, __err := __p.ParseE(Attr{})
		_ = e
		if __err != nil {
			return nil, __err
		}

		res["val"] = e["val"]

	default:
		return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)
	}

	return res, nil
}
