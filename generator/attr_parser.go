package generator

import (
	"bytes"
	"fmt"
	"ll1-parser-generator/grammar"
	"os"
	"path/filepath"
	"strings"
)

func (ctx *Context) GenerateAttrParserGo() error {
	var err error
	ctx.file, err = os.Create(filepath.Join(ctx.Out, "attr_parser.go"))
	if err != nil {
		return err
	}
	defer closeFmt(ctx.file)

	err = ctx.generateHeader()
	if err != nil {
		return err
	}

	err = ctx.generateParser()
	if err != nil {
		return err
	}

	return nil
}

func (ctx *Context) generateHeader() error {
	_, err := ctx.file.WriteString(fmt.Sprintf(`
// Code generated by daniil-ushkov LL(1) parser generator; DO NOT EDIT.
package %s

import (
	"fmt"
	"strconv"
)

func __fmt_unused_import_ignore() {
	fmt.Print()
}

func __strconv_unused_import_ignore() {
	_, _ = strconv.Atoi("12345")
}

func log(val1, val2 int) int {
	res := 0
	for val1 != 1 {
		val1 /= val2
		res++
	}
	return res
}
`, ctx.Package))
	return err
}

func (ctx *Context) generateParser() error {
	_, err := ctx.file.WriteString(`
type AttrParser struct {
	Lexer Lexer
}

type Attr map[string]interface{}
`)
	if err != nil {
		return err
	}

	_, err = ctx.file.WriteString(fmt.Sprintf(`
func (__p *AttrParser) Parse() (Attr, error) {
	return __p.Parse%s(Attr{})
}
`, ctx.Grammar.Desc.StartRule.Name))
	if err != nil {
		return err
	}

	_, nonTerminals := ctx.extractSymbols()
	for nonTerminal := range nonTerminals {
		err = ctx.generateParseFunction(nonTerminal)
		if err != nil {
			return err
		}
	}

	return err
}

const ParseFunctionTmpl = `
func (__p *AttrParser) Parse{{.NonTerminal}}(attr Attr) (Attr, error) {
	res := Attr{}

	_ = res

	switch __p.Lexer.Get().Symbol {
		{{.SwitchBody}}
	default:
		{{.DefaultBody}}
	}

	return res, nil
}
`

type ParseFunctionModel struct {
	NonTerminal string
	SwitchBody  string
	DefaultBody string
}

func (ctx *Context) generateParseFunction(nonTerminal grammar.NonTerminal) error {
	rules := ctx.extractParserRules(nonTerminal)

	switchBodyBuf := bytes.Buffer{}
	for _, rule := range rules {
		stripedRule := rule.Striped()

		terminals := ctx.Grammar.GetFirst(stripedRule)
		if terminals.Has(grammar.EPS) {
			terminals.Erase(grammar.EPS)
			terminals.AddAll(ctx.Grammar.Follow[rule.NonTerminal])
		}

		switchBodyBuf.WriteString(generateCase(terminals, rule))
	}

	executed, _ := execute(ParseFunctionTmpl, ParseFunctionModel{
		NonTerminal: nonTerminal.Name,
		SwitchBody:  switchBodyBuf.String(),
		DefaultBody: `return nil, fmt.Errorf("unexpected symbol: %s, rest: (%s, \"%s\")", __p.Lexer.Get().Symbol.String(), __p.Lexer.Next.Symbol.String(), __p.Lexer.Input)`,
	})

	_, err := ctx.file.WriteString(executed)

	return err
}

func (ctx *Context) extractParserRules(nonTerminal grammar.NonTerminal) []grammar.ParserRule {
	var res []grammar.ParserRule
	for _, rule := range ctx.Grammar.Desc.ParserRules {
		if rule.NonTerminal == nonTerminal {
			res = append(res, rule)
		}
	}

	return res
}

func generateCase(terminals grammar.TerminalSet, parserRule grammar.ParserRule) string {
	caseBodyBuf := bytes.Buffer{}

	var terminalsNames []string
	for terminal := range terminals {
		terminalsNames = append(terminalsNames, terminal.Name)
	}

	caseBodyBuf.WriteString(fmt.Sprintf("case %s:", strings.Join(terminalsNames, ", ")))

	for _, item := range parserRule.Rule {
		switch item1 := item.(type) {
		case grammar.TerminalParserRuleItem:
			caseBodyBuf.WriteString(terminalSwitchFragment(item1))
		case grammar.NonTerminalParserRuleItem:
			caseBodyBuf.WriteString(nonTerminalSwitchFragment(item1))
		case grammar.Code:
			caseBodyBuf.WriteString("\n" + string(item1) + "\n")
		}
	}

	return caseBodyBuf.String()
}

func terminalSwitchFragment(terminalRuleItem grammar.TerminalParserRuleItem) string {
	tmpl := `
if __p.Lexer.Get().Symbol != {{.Terminal.Name}} {
	return nil, fmt.Errorf("{{.Terminal.Name}} expected")
}
{{.Alias}} := __p.Lexer.Get().Lexeme
_ = {{.Alias}}
__p.Lexer.MoveNext()
`
	executed, _ := execute(tmpl, terminalRuleItem)
	return executed
}

func nonTerminalSwitchFragment(nonTerminalParserRuleItem grammar.NonTerminalParserRuleItem) string {
	tmpl := `
{{.Alias}}, __err := __p.Parse{{.NonTerminal.Name}}(Attr{ {{- .Attrs -}} })
_ = {{.Alias}}
if __err != nil {
	return nil, __err
}
`
	executed, _ := execute(tmpl, nonTerminalParserRuleItem)
	return executed
}
