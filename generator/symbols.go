package generator

import (
	"bytes"
	"fmt"
	"ll1-parser-generator/grammar"
	"os"
	"path/filepath"
)

const SymbolsGoTmpl = `
// Code generated by daniil-ushkov LL(1) parser generator; DO NOT EDIT.
package {{.Package}}

//go:generate stringer -type=Terminal
type Terminal int

const (
	{{.Terminals}}
)

//go:generate stringer -type=NonTerminal
type NonTerminal int

const (
	{{.NonTerminals}}
)
`

type SymbolsGoModel struct {
	Package      string
	Terminals    string
	NonTerminals string
}

func (ctx *Context) GenerateSymbolsGo() error {
	var err error
	ctx.file, err = os.Create(filepath.Join(ctx.Out, "symbols.go"))
	if err != nil {
		return err
	}
	defer closeFmt(ctx.file)

	terminals, nonTerminals := ctx.extractSymbols()

	executed, _ := execute(SymbolsGoTmpl, SymbolsGoModel{
		Package:      ctx.Package,
		Terminals:    createTerminalEnum(terminals),
		NonTerminals: createNonTerminalEnum(nonTerminals),
	})

	_, err = ctx.file.WriteString(executed)

	return err
}

func (ctx *Context) extractSymbols() (grammar.TerminalSet, grammar.NonTerminalSet) {
	terminals := grammar.NewTerminalSet()
	nonTerminals := grammar.NewNonTerminalSet()

	terminals.Add(grammar.Terminal{Name: "EOF"})

	for _, rule := range ctx.Grammar.Desc.LexerRules {
		terminals.Add(rule.Terminal)
	}

	for _, rule := range ctx.Grammar.Desc.ParserRules {
		nonTerminals.Add(rule.NonTerminal)
	}

	return terminals, nonTerminals
}

func createTerminalEnum(set grammar.TerminalSet) string {
	buf := bytes.Buffer{}
	first := true
	for terminal := range set {
		if first {
			buf.WriteString(fmt.Sprintf("%s Terminal = iota\n", terminal.Name))
			first = false
		} else {
			buf.WriteString(terminal.Name + "\n")
		}
	}
	return buf.String()
}

func createNonTerminalEnum(set grammar.NonTerminalSet) string {
	buf := bytes.Buffer{}
	first := true
	for nonTerminal := range set {
		if first {
			buf.WriteString(fmt.Sprintf("%s NonTerminal = iota\n", nonTerminal.Name))
			first = false
		} else {
			buf.WriteString(nonTerminal.Name + "\n")
		}
	}
	return buf.String()
}
